---
title: "assignment 4"
author: "Sara Ã˜stergaard"
date: "21/4/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(pacman)
pacman::p_load(
  tidyverse,
  here,
  posterior,
  cmdstanr,
  brms, 
  boot, 
  loo,
  patchwork
)

source('util.R')
```

## Simulate data
```{r}

# parameters
temp <- 0.5 # same for both conditions
alpha_cond1 <- 0.6
alpha_cond2 <- 0.8
p <- 0.75  # probability that choice 1 gives a reward

# define number of trials
n_trials <- 1000

# make sure the dataframe doesn't exist
d <- NULL


# simulate
for (cond in 1:2){
  print(paste("condition = ", cond))
  # simulate bot
  correct_choice <- rbinom(n_trials, 1, p)
  # initialize values for the two choices
  values <- c(0,0)
  # define correct learning rate for the condition
  alpha <- ifelse(cond==1, alpha_cond1, alpha_cond2)
  print(alpha)
  # make tmp dataframe
  tmp <- tibble(
    choice = rep(0, n_trials),
    value1 = rep(0, n_trials),
    value2 = rep(0, n_trials),
    feedback = rep(0, n_trials),
    condition = rep(0, n_trials),
    trial = rep(0, n_trials),
    learning_rate = rep(0, n_trials)
  )
  
  for (trial in 1:n_trials){
    if (trial %% 100 == 0){
     print(paste("trial = ", trial)) 
    }
    
    choice <- rbinom(1, 1, softmax(values[2]-values[1], temp))
    feedback <- ifelse(correct_choice[trial]==choice, 1, -1)
    values <- valueUpdate(values, alpha, choice, feedback)
    
    # fill in dataframe
    tmp$choice[trial] <- choice + 1
    tmp$value1[trial] <- values[1]
    tmp$value2[trial] <- values[2]
    tmp$feedback[trial] <- feedback
    tmp$condition[trial] <- cond
    tmp$trial[trial] <- trial
    tmp$learning_rate[trial] <- alpha
    
  }
  if (exists("d")){
    d <- rbind(d, tmp)
  } else {
    d <- tmp
  }
}


```

```{r}
# save simulated data
write_csv(d, "simulated_data.csv")
```


## model
```{r}
# load model
file <- file.path('reinforcement_learning.stan')
mod <- cmdstan_model(file, cpp_options = list(stan_threads=TRUE))
print("Done compiling!")
```
Prepare data and run model
```{r}
# make data frames to make into matrices
df_cond <- d %>% mutate(cond = condition-1) %>% 
  subset(select=c(cond, condition, trial)) %>% 
  pivot_wider(names_from = condition, values_from = cond)

df_choice <- d %>% subset(select=c(choice, condition, trial)) %>% 
  pivot_wider(names_from = condition, values_from = choice)

df_feedback <- d %>% subset(select=c(feedback, condition, trial)) %>% 
  pivot_wider(names_from = condition, values_from = feedback)

# data for the model
data <- list(
  trials = max(d$trial),
  cond = as.matrix(df_cond[,2:3]),
  choice = as.matrix(df_choice[,2:3]),
  feedback = as.matrix(df_feedback[,2:3])
)

# call stan
samples <- mod$sample(
  data = data,
  seed = 123,
  chains = 2,
  parallel_chains = 2,
  threads_per_chain = 2,
  iter_warmup = 1000,
  iter_sampling = 2000,
  refresh = 1000,
  max_treedepth = 20,
  adapt_delta = 0.99
)

```

```{r}
samples$summary()

draws_df <- as_draws_df(samples$draws())
```

chains
```{r}
ggplot(draws_df, aes(.iteration, alpha1, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

ggplot(draws_df, aes(.iteration, alpha2, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()
```
prior posterior update
```{r}
alpha1_update <- ggplot(draws_df) +
  geom_density(aes(alpha1_transformed), fill='blue', alpha=0.5) + 
  geom_density(aes(alpha1_prior), fill='red', alpha=0.5) + 
  theme_bw()

alpha2_update <- ggplot(draws_df) +
  geom_density(aes(alpha2_transformed), fill='blue', alpha=0.5) + 
  geom_density(aes(alpha2_prior), fill='red', alpha=0.5) + 
  theme_bw()

alpha1_update + alpha2_update
```



## parameter recovery


